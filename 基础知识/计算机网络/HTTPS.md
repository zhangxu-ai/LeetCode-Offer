# HTTPS

HTTPS 则解决 HTTP 不安全的缺陷，在 TCP 和 HTTP 网络层之间加入了 SSL/TLS 安全协议，使得报文能够加密传输。

1. **混合加密**的方式实现信息的机密性**，解决了窃听的风险。
2. **摘要算法**的方式来实现**完整性**，它能够为数据生成独一无二的「指纹」，指纹用于校验数据3的完整性，解决了篡改的风险。
3. 将服务器公钥放入到**数字证书**中，解决了冒充的风险。

## 混合加密

![hhjm](https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/20-%E6%B7%B7%E5%90%88%E5%8A%A0%E5%AF%86.png)

HTTPS 采用的是**对称加密**和**非对称加密**结合的「混合加密」方式：

1. 在通信建立前采用非对称加密的方式交换「会话秘钥」，后续就不再使用非对称加密。
2. 在通信过程中全部使用对称加密的「会话秘钥」的方式加密明文数据。

什么是对称加密和非对称加密：

1. **对称加密**：即通信的双方都使用**同一个秘钥**进行加解密，比如特务接头的暗号，就属于对称加密
2. **非对称加密**：
   1. 私钥 + 公钥= 密钥对
   2. 即用私钥加密的数据,只有对应的公钥才能解密,用公钥加密的数据,只有对应的私钥才能解密
   3. 因为通信双方的手里都有一套自己的密钥对,通信之前双方会先把自己的公钥都先发给对方
   4. 然后对方再拿着这个公钥来加密数据响应给对方,等到到了对方那里,对方再用自己的私钥进行解密

为什么要混合加密：

1. 对称加密只使用一个密钥，**运算速度快**，密钥必须保密，无法做到安全的密钥交换。
2. 非对称加密使用两个密钥：公钥和私钥，公钥可以任意分发而私钥保密，解决了密钥交换问题但**速度慢**。

## 摘要算法

摘要算法用来实现完整性，能够为数据生成独一无二的「指纹」，用于校验数据的完整性，解决了篡改的风险。

![zysf](https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/21-%E6%A0%A1%E9%AA%8C%E5%AE%8C%E6%95%B4%E6%80%A7.png)

客户端在发送明文之前会通过摘要算法算出明文的「指纹」，发送的时候把「指纹 + 明文」一同加密成密文后，发送给服务器，服务器解密后，用相同的摘要算法算出发送过来的明文，通过比较客户端携带的「指纹」和当前算出的「指纹」做比较，若「指纹」相同，说明数据是完整的。

## 数字证书

服务器向CA申请证书，将服务器公钥放在数字证书（由数字证书认证机构颁发）中，只要证书是可信的，公钥就是可信的。

![szzs](https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/22-%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png)

## 连接流程

1. 客户端发送自己的公钥，请求服务器公钥+CA数字签名
2. 根据CA的 公钥解密CA数字签名，确定服务器公钥的稳定性
3. 得到了正确的服务器公钥，用双方协商的加密算法，各自生成本次通信的「会话秘钥」
4. 使用会话秘钥进行对称加密会话

1，2，,3也叫SSL/TLS握手阶段

## HTTP/1.1,HTTP/2.0

### HTTP/1.1

1. 增加了长连接
改善了短连接带来的性能问题
2. 支持管道通信
但是因为是顺序的，如果一个堵塞，后面也要堵塞
3. 头部无法压缩
4. 首部冗长

### HTTP/2.0

1. **压缩头**（Header）
如果你同时发出多个请求，他们的头是一样的或是相似的，那么，协议会帮你消除重复的部分。
这就是所谓的 `HPACK` 算法：在客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就提高速度了。
2. 数据为**二进制格式**，机器友好，增加了数据传输速率
3. **多路复用**
一个连接中并发多个请求或回应，而不用按照顺序一一对应。降低了延迟，大幅度提高了连接的利用率。
4. **数据流**
数据包不是按顺序发送的，同一个连接里面连续的数据包，可能属于不同的回应。因此，必须要对数据包做标记，指出它属于哪个回应。
每个请求或回应的所有数据包，称为一个数据流（Stream）。

5. 
