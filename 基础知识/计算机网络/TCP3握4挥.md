# TCP3握4挥

## 3次握手

![3w](https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjA1MTEwNDA1NjY2?x-oss-process=image/format,png)

1. 第一次握手 c->s
   1. 发送带有SYN (同步信号)标志的数据包
   2. 确认了：
      1. s:c发送正常，s接收正常
2. 第二次握手 s->c
   1. 回传SYN信号，并且加上ACK(确认信号)
      1. 回传的原因：确认我收到的确实是你发的信号
      2. 为啥要加ACK:传了 SYN，证明发送方到接收方的通道没有问题，但是**接收方到发送方的通道还需要 ACK 信号来进行验证。**
   2. 确认了：
      1. s: c发送正常，s接收正常；
      2. c：c发送、接收都正常;s接收、发送都正常
3. 第三次握手 c->s
   1. 回传ACK信号
      1. 回传的原因：确认我收到的确实是你发的信号
   2. 确认了：
      1. s:c发送、`接收`都正常;s发送、`接收`都正常
      2. c:c发送、接收都正常;s发送、接收都正常
   3. 防止已经失效的连接请求报文突然又传送到了服务器，从而产生错误

## 4次挥手

![4h](https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjA2MDg0ODUxMjcy?x-oss-process=image/format,png)

1. 第一次挥手：c->s
   1. c发送一个 FIN，用来关闭客户端到服务器的数据传送
   2. **c确定不再发送数据**了
2. 第二次挥手：s—>c
   1. s发送一个ACK信号
   2. s通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是**服务器若发送数据，客户端依然要接受**。这个状态还要持续一段时间，也就是整个`CLOSE-WAIT`状态持续的时间。
3. 第三次挥手：c->s
   1. 客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（**在这之前还需要接受服务器发送的最后的数据**）。
4. 第四次挥手
   1. 客户端收到服务器的连接释放报文后，**必须发出确认**，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过`2*MSL`（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。
   2. 服务器只要收到了客户端发出的确认，**立即进入CLOSED状态**。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。
5. 为什么要有4次挥手：
建立连接的时候， 服务器在LISTEN状态下，收到建立连接请求的SYN报文后，**把ACK和SYN放在一个报文里发送给客户端**。
而关闭连接时，服务器收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也**未必全部数据都发送给对方了**，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，**己方ACK和FIN一般都会分开发送**，从而导致多了一次。
6. 为什么客户端最后还要等待2MSL？
MSL是Maximum Segment Lifetime的缩写，译为报文最大生存时间，也就是任何报文在网络上存活的最大时间，**一旦超过该时间，报文就会被丢弃**。
去向ACK消息最大存活时间（MSL) + 来向FIN消息的最大存活时间(MSL)。
   1. 保证最后一个ack能到达，如果出现延迟，客户端就能在这个2MSL时间段内收到这个重传的报文
   2. 使本连接持续的时间内所产生的所有报文段都从网络中消失。这样新的连接中不会出现旧连接的请求报文。