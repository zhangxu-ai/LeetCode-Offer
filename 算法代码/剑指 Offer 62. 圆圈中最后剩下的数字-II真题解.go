package main

//数学+递归
//40,34
/*
假设f(n-1,m)=x，然后来找一找f(n,m)和f(n-1,m)到底啥关系。
f(n-1,m)=x意味着啥呢？
意味着有n-1个数的时候从index=0开始数，数x+1个数你就找到这结果了。
那我不从index=0开始数呢？比如我从index=i开始数？
那很简单，你把上面的答案也往后挪i下，就得到答案了。
当然了，你要是挪到末尾了你就取个余，从头接着挪。
我们划完了这个数，往后数x+1下，能落到谁身上呢，它的下标是几？
你往后数x+1，它下标肯定变成了(m-1)%n +x+1，
和第一步的想法一样，你肯定还是得取模，所以答案为[(m-1)%n+x+1]%n，则
f(n,m)=[(m-1)%n+x+1]%n
其中x=f(n-1,m)
化简得 f(n,m)=(m+x)%n
*/
func lastRemaining2(n int, m int) int {
	if n == 1 {
		return 0
	}
	x := lastRemaining2(n-1, m)
	return (m + x) % n
}

//数学+迭代
//99,74
/*
倒着推，不要看值是多少，只需要关心下标即可，
然后我们从最后剩下的 x 倒着看，我们可以反向推出这个数字在之前每个轮次的位置。

最后剩下的 x 的下标是 0,意味着他是上一轮（第四轮）中第m+1个数，那么它前面有m个数

但是要考虑最后一轮只剩了2个数，所以对于m=3来说，其实是取模之后的下标

如图（只关心下标），括号内为下标
x(0) ->
第四轮: x4(0) x(1) ->
第三轮: x4(0) x(1) x3(2)

第四轮反推，补上 m 个位置，然后模上当时的数组大小 2，位置是(0 + 3) % 2 = 1。

第三轮反推，补上 m 个位置，然后模上当时的数组大小 3，位置是(1 + 3) % 3 = 1。

第二轮反推，补上 m 个位置，然后模上当时的数组大小 4，位置是(1 + 3) % 4 = 0。

第一轮反推，补上 m 个位置，然后模上当时的数组大小 5，位置是(0 + 3) % 5 = 3。
*/
func lastRemaining3(n int, m int) int {
	//最后剩的一个下标肯定为0
	idx := 0
	//从倒数第一轮（剩2个数）开始往上面推
	for i := 2; i <= n; i++ {
		idx = (m + idx) % i
	}
	return idx
}
