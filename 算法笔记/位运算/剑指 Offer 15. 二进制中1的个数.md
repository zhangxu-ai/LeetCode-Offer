# 剑指 Offer 15. 二进制中1的个数

## 题目

请实现一个函数，输入一个整数（以二进制串形式），输出该数二进制表示中 1 的个数。例如，把 9 表示成二进制是 1001，有 2 位是 1。因此，如果输入 9，则该函数输出 2。

示例 1：
输入：00000000000000000000000000001011
输出：3
解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 '1'。

示例 2：
输入：00000000000000000000000010000000
输出：1
解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 '1'。

示例 3：
输入：11111111111111111111111111111101
输出：31
解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 '1'。

## 思考

先来复习下 go 中的 位运算：

1. 与 `&`
& 是当 两个数需要同时为1的时候才会保留。 例如 `0000 0100 & 0000 1111 => 0000 0100 => 4`
可以用来判断奇偶数
数一个数的二进制中1的个数
2. 或 `|`
| 是当 两个数有一个为1的时候会保留。 例如 `0000 0100 | 0000 1111 => 0000 1111 => 15`
3. 异或 `^`
即可作为二元运算符，也可作为一元运算符。
作为一元运算符，是按位取反的意思。
当作为二元运算符，是 亦或 ，**即两个数的二进制位不同时,当前位才置1 否则置0**
**任何数和本身异或 结果为0, 0和任意数异或 结果为其本身**

    ```go
    4 | 15 = 11
    ---------------
    00000100 ^
    00001111
    00001011
    =11
    ```

    应用：
    1. 数值交换
    Go中数值交换可以直接通过a, b = b, a这样的方式来直接交换,位运算是怎么实现交换的呢？

        ```go
        a ^= b // a = a^b
        b ^= a // b = b^(a^b) b和b自己异或为0 相当于 b=a
        a ^= b // a = (a^b)^a a在第一步中已经为a^b，现在的b 已经等于a a互相抵消 完成了值的交换
        ```

    2. 寻找列表中只出现一次的数字
    假如一个列表中有2*N+1个数，其中一个数字只出现了一次。其他的数都出现了两次。如何寻找这个数字
    利用**任何数和自己异或的结果将为0的特性**，遍历异或一遍
4. 位清空运算符 AND NOT &^
对于 `c=a&^b`，c的值是 a， 其中对应的位置上的b的值如果为1，则此位置零，

    ```go
    4 &^ 15 = 0
    ---------------
    00000100 &^
    00001111
    00000000
    =0
    ```

## 代码

```go
func hammingWeight(num uint32) int {
	res:=0
	for num != 0 {
		if num&1==1{
			res++
		}
		num>>=1
	}
	return res
}

//优化方案
/*
   10110001 &  //初始值
   10110000    //减1后
  =10110000 &  //找出最低位的1
   10101111   //继续减1
  =10100000   //找出最低位的1
   ....       //直到找不出1即为0
*/

func BitCheck(i int)(count int){
	for i>0{
		count += 1
		i &= i-1
	}
	return
}

```
