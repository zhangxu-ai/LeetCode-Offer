# 剑指 Offer 68 - II. 二叉树的最近公共祖先

## 题目

给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。

百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”

例如，给定如下二叉树:  `root = [3,5,1,6,2,0,8,null,null,7`

示例 1:
输入: `root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1`
输出: 3 解释: 节点 5 和节点 1 的最近公共祖先是节点 3。

示例2:
输入: `root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4`
输出: 5 解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。

## 思考

1. 找完路径，然后对比
这一题和上一题细节不同，上一题是二叉搜索树，可以根据大小来确定路径，在找一趟里就能找到；这一题不是搜索树，无法通过每个节点的Val确定p或q的位置，所以必须要把两个路径找到，存到数组里；然后遍历这两个数组，找到第一个 位置相同但是值不同的节点，就是最深祖先节点
2. 前序遍历法
对于p和q2个节点，他们的祖先节点有规律的。比如，`[1,2,3]`,2和3的祖先节点是1；如果用前序遍历，让2和3返回自己；在1处判断：如果2个返回值都不是空，说明自己是他俩的祖先节点；对于`[1,2,3,4,5,6,7,8]`,5和8的祖先节点是2，怎么来的呢？遍历到8时，返回自己，是8；4收到8的返回，但是没有右节点，返回nil，这种情况下；说明4一定不是他们的最深祖先节点；8本身有可能是，因为如果5是8的子节点，则他们的祖先节点就是8本身；所以目前无法确定8是不是，那就把8返回；到2处，左节点返回8，右节点是5，返回5；这个时候，左右节点均不为空，说明2就是最深的公共节点,返回2到1；这个时候1的右边返回nil，最后返回了2.

## 代码

```go
func lowestCommonAncestor(root, p,  q *TreeNode) *TreeNode {
	if root==nil{
	    return nil
	}
	if root==p||root==q{
	    return root
	}
	left:=lowestCommonAncestor(root.Left,p,q)
	right:=lowestCommonAncestor(root.Right,p,q)
    //左右两边都没有，则自己一定不是
	if left==nil&&right==nil{
		return nil
        //就在自己的左右两边，自己一定是
	}else if left!=nil&&right!=nil{
		return root
    //p或q或祖先节点在自己的左边，不敢怠慢，护送离开
	}else if left!=nil{
		return left
	}else{
		return right
	}
}
```
